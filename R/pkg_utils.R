#' @title Remove all functions in the global environment
#' @description Helper function for wipping custom functions in the global env
#' @return NULL
wipe_functions <- function(){
  as.character(utils::lsf.str(pos = globalenv())) %>%
    lapply(function(x){
      rm(list = x, envir = globalenv())
    })
  invisible()
}

#' @title Lazy wrapper for reloading fake package if it is already loaded
#' @description Lazy wrapper for reloading fake package if it is already loaded.
#' @param dev if TRUE, enter development mode (via `pkgload::load_all()`). If FALSE, enter default mode (via `vmisc::load_all2()`). Development mode allows newly recompiled C++ code to be included in the package, but copies the .dll file for each time it is initiated, which can cause memory overflow, especially in multisession parallel computing.
#' @param package name of fake package
#' @param show_conflicts If TRUE and dev = FALSE, prints the conflict message.
#' @return NULL
reload <- function(dev = FALSE, package = fake_pkg(), show_conflicts = FALSE){
  if(dev){
    pkgload::load_all(package)
  } else {
    vmisc::load_all2(package, show_conflicts = FALSE)
  }
}

#' @title Recompile C++ code
#' @description Recompile C++ code for a specified package with `pkgload`
#' @param package the name of the package to recompile C++ code
#' @return NULL
recompile <- function(package = fake_pkg()){
  pkgload::load_all(pkgload::pkg_path(package))
}


#' @title Find fake package generated by `vmisc::load_all2()` or `pkgload::load_all()`
#' @description
#' Find fake package generated by `vmisc::load_all2()` or `pkgload::load_all()`
#' @param fake_pkg_root_path the root path of where the fake package is installed at
#' @return the name of the fake package
fake_pkg <- function(fake_pkg_root_path = getwd()){
  pkg <- .packages()
  pkg[dirname(path.package(pkg)) %in% fake_pkg_root_path]
}

#' @title Find package version
#' @description same as `utils::packageVersion()` but with error handling
#' @param x the name of the package
#' @return the package version
package_version2 <- function(x){
  tryCatch(utils::packageVersion(x),
           error = function(e){
             "version not found"
  })
}

#.tidyverse_attach <- utils::getFromNamespace("tidyverse_attach", "tidyverse")

# Stolen from tidyverse
.confirm_conflict <- function (packages, name)
{
  objs <- packages %>% purrr::map(~get(name, pos = .)) %>%
    purrr::keep(is.function)
  if (length(objs) <= 1)
    return()
  objs <- objs[!duplicated(objs)]
  packages <- packages[!duplicated(packages)]
  if (length(objs) == 1)
    return()
  packages
}


.vmisc_dependencies <- function(include_self = TRUE){
  raw <- paste(utils::packageDescription("vmisc")$Imports,
               utils::packageDescription("vmisc")$Depends, sep = ",")
  imports <- strsplit(raw, ",")[[1]]
  parsed <- gsub("^\\s+|\\s+$", "", imports)
  names <- vapply(strsplit(parsed, "\\s+"), "[[", 1, FUN.VALUE = character(1))
  if (include_self) {
    names <- c(names, "vmisc")
  }
  names
}

# Stolen from tidyverse
.pkg_conflicts <- function(message = TRUE){
  envs <- grep("^package:", search(), value = TRUE)
  envs <- purrr::set_names(envs)
  objs <- lapply(envs, function(env) {
    x <- ls(pos = env)
    x
  })
  if (length(objs) == 0) {
    objs <- objs
  }
  else {
    stacked <- utils::stack(objs)
    objs <- tapply(as.character(stacked$ind), stacked$values,
                   list)
  }
  conflicts <- purrr::keep(objs, ~length(.x) > 1)
  tidy_names <- paste0("package:", .vmisc_dependencies())
  conflicts <- purrr::keep(conflicts, ~any(.x %in% tidy_names))
  conflict_funs <- purrr::imap(conflicts, .confirm_conflict)
  x <- purrr::compact(conflict_funs)

  if (length(x) == 0){
    res <- ""
  } else {
    header <- cli::rule(left = cli::style_bold("Conflicts"), right = ".pkg_conflicts()")
    pkgs <- x %>% purrr::map(~gsub("^package:", "", .))
    others <- pkgs %>% purrr::map(`[`, -1)
    other_calls <- purrr::map2_chr(others, names(others), ~paste0(cli::col_blue(.x),
                                                                  "::", .y, "()", collapse = ", "))
    winner <- pkgs %>% purrr::map_chr(1)
    funs <- format(paste0(cli::col_blue(winner), "::", cli::col_green(paste0(names(x),
                                                                             "()"))))
    bullets <- paste0(cli::col_red(cli::symbol$cross), " ", funs,
                      " masks ", other_calls, collapse = "\n")
    res <- paste0(header, "\n", bullets)
    res <- text_col(res)
  }

  if(message){
    cli::cat_line(res)
  }
  invisible(res)
}

#' @title Detach vmisc
#' @description Detaches vmisc
#' @param x does nothing
#' @return NULL
detach.vmisc <- function(x){
  message("detatching package. . . ")
  if ("vmisc" %in% (.packages())) {
    detach("package:vmisc", unload = TRUE)
    message("goodbye!")
  }
  else {
    cli::cli_inform("package is not loaded and therefore cannot be unloaded.")
  }
}

.reinstall.vmisc <- function(
    source = c("github", "source"), package_path = NULL, ...){
  load.vmisc <- "vmisc" %in% (.packages())
  detach.vmisc()
  if(match.arg(source) == "github"){
    devtools::install_github("vsbpan/vmisc", dependencies = TRUE, force = TRUE)
  } else {
    if(is.null(package_path)){
      cli::cli_abort("Package path is null.")
    }
    if(!file.exists(package_path)){
      cli::cli_abort("Cannot find the file {.path {package_path}}")
    }
    utils::install.packages(package_path, repos = NULL, type = "source")
  }
  rstudioapi::restartSession()
  if (load.vmisc) {
    library(vmisc)
  }
}

.onAttach <- function(...){
  packageStartupMessage(
    text_col(cli::rule(cli::style_bold(paste0("Attached vmisc ", package_version2("vmisc")))))
  )
  packageStartupMessage("")
  #.tidyverse_attach()
  if (!"package:conflicted" %in% search()) {
    packageStartupMessage(.pkg_conflicts(message = FALSE))
  }
}


fake_pkg_onAttach <- function(path = fake_pkg(), show_conflicts = TRUE){
  pkg <- basename(path)
  if(!pkg %in% .packages()){
    packageStartupMessage(
      text_col(cli::rule(cli::style_bold(paste0("Attached ", pkg, " ", package_version2(pkg)))))
    )
    packageStartupMessage("")
  }
  if(show_conflicts){
    if (!"package:conflicted" %in% search()) {
      packageStartupMessage(.pkg_conflicts(message = FALSE))
    }
  }
}

